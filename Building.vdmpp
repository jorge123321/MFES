class Building
types
	 public Points = set of PointOfInterest;
	 public Transports = set of Transport;
	 public Equipments = set of Equipment;
	 public Edge = set of PointOfInterest
  	inv e == card(e)=2;
   public Weight = int;
  
	 public Graph :: e : Edge
	 									w : Weight;
	 	 

	 

values
	public min_lines : int = 3;
	public max_lines : int = 5;
	public min_columns : int = 3;
	public max_columns : int = 5;
	public min_floors : int = 1;
	public max_floors : int = 1;

instance variables
	public points : Points := {};
	public transports : Transports := {};
	public equipments : Equipments := {};
	public path : Points := {};
	public origin : PointOfInterest;
	public destination : PointOfInterest;
	public s : PointOfInterest;
	public C: Points := {};
 	public Q: Points := {}; -- := points??
 	public dist: map PointOfInterest to nat := {|->};
 	public pred: map PointOfInterest to PointOfInterest := {|->};
 	public edges : set of Points := {};
 	public weights : set of nat := {1};
 	public graph : set of Graph := {};
 	public wgraph : set of Graph := {};


functions
	-- checks if we're only moving 1 position at a time, ie one move on the x left or right, one move on y up or down and one move on z up or down
	public moveIsValid : nat * nat * nat -> bool
			moveIsValid(deltaX, deltaY, deltaZ) == (
				(deltaX = 0 and deltaY = 0 and deltaZ = 1) or
				(deltaX = 0 and deltaY = 0 and deltaZ = -1) or
				(deltaX = 1 and deltaY = 0 and deltaZ = 0) or
				(deltaX = -1 and deltaY = 0 and deltaZ = 0) or
				(deltaX = 0 and deltaY = 1 and deltaZ = 0) or
				(deltaX = 0 and deltaY = -1 and deltaZ = 0)
			);
			
	public IsShortestPath: map PointOfInterest to nat * map PointOfInterest to PointOfInterest * set of PointOfInterest * PointOfInterest * set of Graph * Points -> bool
	 IsShortestPath(dist, pred, C, s, graph,points) == 
	 	DefinesShortestDist(dist, pred, C, s, graph) and	SetOfLinkedVertices(C,s,graph, points);	 
		
	public DefinesShortestDist: map PointOfInterest to nat * map PointOfInterest to PointOfInterest * set of PointOfInterest * PointOfInterest * set of Graph -> bool
 	DefinesShortestDist(dist, pred, C, s, graph) == 
 	(dist(s)=0 and 
 		forall u in set C\{s} & (exists v in set C & (
 			pred(u)=v and neighbour(graph, u, v) and
 			let tup in set graph be st tup.e={u,v} in (dist(u)=dist(v)+tup.w)))
 		and
 		forall u1, v in set C & (neighbour(graph, u1, v) =>
 				let tup in set graph be st tup.e={u1,v} in (dist(u1)<=dist(v)+tup.w))
 );
 
 public SetOfLinkedVertices: set of PointOfInterest * PointOfInterest * set of Graph * Points -> bool
 	SetOfLinkedVertices(C,s,graph,points) ==
 	(forall u in set C & (forall v in set points & neighbour(graph, u, v) => v in set C) and
 		forall u1 in set C\{s} & (exists v in set C & neighbour(graph, u1, v))
 	);
 	
 	public neighbour: set of Graph * PointOfInterest * PointOfInterest	-> bool
		neighbour(wg, i, j) ==
 		exists tup in set wg & (tup.e={i,j} and tup.w>0);

operations

	public getPoints:() ==> Points
		getPoints() == (
			return points;
		);
		
	--create a building
	public Building:() ==> Building
	Building() == (		
		for i = 0 to (max_lines - 1) do
		(
			for j = 0 to (max_columns - 1) do
			(
					for k = 0 to (max_floors - 1) do 
					(
						dcl point: PointOfInterest := new PointOfInterest(i,j,k,<Null>);
						addPoint(point);
					)
			)
		);
		
			--for all p in set points do (
			--	let neighbours = {n | n in set getNeighbours(p)} in(
			--		let edges={mk_Edge(p,n) | p in set points,
			--	)
			--);
			for all p in set points do(
				let tedges = {{p,e2}| e2 in set getNeighbours(p) & e2.GetDesc() <> <Wall>} in(
				
					edges := edges union tedges;
				)
			);
			
			let tedges = {e | e in set edges} in(
				let tgraph = {mk_Graph(e,w) | e in set edges, w in set weights} in (
					graph := tgraph;
				)
			)
		);
		
		
	--Dijkstra
	public dijkstra: () ==> Building`Points * map PointOfInterest to int * map PointOfInterest to PointOfInterest
		dijkstra() == (
			Q := points;
			s := origin;
			C := C union {s};
			dist := dist ++ {s|->0};
			pred := dist ++ {s|->s};
			wgraph := graph;
			
			
			while(C inter Q <> {}) do (
				let u in set C inter Q be st (forall u1 in set C inter Q & dist(u)<=dist(u1)) in (
					Q := Q\{u};
				
					for all v in set Q do(
						if(u in set getNeighbours(v)) then(
							let uv in set wgraph be st uv.e={u,v} in(
								if uv.w > 0 then (
									let length=dist(u)+uv.w in(
										if v in set C then(
											if length < dist(v) then(
												dist := dist ++ {v|->length};
												pred := pred ++ {v|-> u};
											)
										)
										else (
											dist := dist ++ {v|->length};
											pred := pred ++ {v|->u};
											C := C union {v};
										)
									)
								)
							)
						)
					);				
				)
			);
			return mk_(C,dist,pred);
	)
	
	post IsShortestPath(dist, pred, C, s, graph,points);
	
		-- Add an origin point to the building for the algorithm 
	public addOrigin: nat * nat * nat ==> bool
		addOrigin(x,y,z) == (
			for all p in set points do (
				if p.GetX() = x and p.GetY() = y and p.GetZ() = z
				then (
					changePoint(p, x, y, z, <Origin>);
					origin := p;
					return true;
				)
			);
			return false;
		);
		--pre --TODO: maybe check that the point CAN be set as origin? like it's a clear path or not a wall
		--post --TODO: maybe check that the point WAS set as origin? like it's description indicates origin
		
	-- Add an origin point to the building for the algorithm 
	public addDestination: nat * nat * nat ==> bool
		addDestination(x,y,z) == (
			for all p in set points do (
				if p.GetX() = x and p.GetY() = y and p.GetZ() = z
				then (
					changePoint(p, x, y, z, <Destination>);
					destination := p;
					return true;
				)
			);
			return false;
		);
		--pre P in set points --TODO: maybe check that the point CAN be set as destination? like it's a clear path or not a wall
		--post P in set points; --TODO: maybe check that the point WAS set as destination? like it's description indicates destination
		
		-- checks if building has only 1 destination point
		public hasDestination : () ==> bool
			hasDestination() == (
				dcl pointsDestination : Points := {};
				for all p in set points do (
					if p.GetDesc() = <Destination>
					then (
						pointsDestination := pointsDestination union {p};
					)
				);
				if card(pointsDestination) = 1 then (
					return true;
				) else ( return false; )
			);
			
		-- checks if building has only 1 origin point
		public hasOrigin : () ==> bool
			hasOrigin() == (
				dcl pointsOrigin : Points := {};
				for all p in set points do (
					if p.GetDesc() = <Origin>
					then (
						pointsOrigin := pointsOrigin union {p};
					)
				);
				if card(pointsOrigin) = 1 then (
					return true;
				) else ( return false; )
			);
		
	-- Add a point to the building
	public addPoint: PointOfInterest ==> ()
		addPoint(P) == (
				points := points union {P};
			return;
		)
		pre P not in set points
		post P in set points;
		
	-- Add a stair to the building
	public addTransport: Transport ==> ()
		addTransport(T) == (
				transports := transports union {T};
			return;
		)
		pre T not in set transports
		post T in set transports;
		
	-- Add an equipment to the building
	public addEquipment: Equipment ==> ()
		addEquipment(E) == (
				equipments := equipments union {E};
			return;
		)
		pre E not in set equipments
		post E in set equipments;
		
	-- Change X Y Z and Description of point of interest 
	public changePoint: PointOfInterest*nat*nat*nat*PointOfInterest`Type ==> ()
		changePoint(P,newx, newy, newz, newdesc) == (
			P.changePoint(newx, newy,newz,newdesc);
			return;
		)
		pre P in set points;
	
	-- Change X Y, Description, DownFloor, UpFloor and Type of stair
	public changeTransport: Transport*Transport`X * Transport`Y * Transport`Desc * Transport`DownFloor * Transport`UpFloor * Transport`Type ==> ()
		changeTransport(T,newx, newy, newdesc, newdown, newup, newtype) == (
			T.changeTransport(newx, newy, newdesc, newdown, newup, newtype);
			return;
		)
		pre T in set transports;
		
	-- Change X Y, Z and name of equipment
	public changeEquipment: Equipment * Equipment`X * Equipment`Y * Equipment`Z * Equipment`Name ==> ()
		changeEquipment(E, newx, newy, newz, newname) == (
			E.changeEquipment(newx, newy, newz, newname);
			return;
		)
		pre E in set equipments;
	
	-- Remove point of interest
	public removePoint: PointOfInterest ==>()
		removePoint(P) == (
			points := points \ {P};
			return;
		)
		pre P in set points
		post P not in set points;
	
	-- Remove transport
	public removeTransport: Transport ==>()
		removeTransport(T) == (
			transports := transports \ {T};
			return;
		)
		pre T in set transports
		post T not in set transports;
		
	-- Remove equipment
	public removeEquipment: Equipment ==>()
		removeEquipment(E) == (
			equipments := equipments \ {E};
			return;
		)
		pre E in set equipments
		post E not in set equipments;
		
		--Remove all points
		public removePoints:() ==> ()
			removePoints() == (
				points := points \ points;
			) 
		pre points <> {}
		post points = {};
		
		--Remove all transports
		public removeTransports:() ==> ()
			removeTransports() == (
				transports := transports \ transports;
			) 
		pre transports <> {}
		post transports = {};
		
		--Remove all equipments
		public removeEquipments:() ==> ()
			removeEquipments() == (
				equipments := equipments \ equipments;
			) 
		pre equipments <> {}
		post equipments = {};
		
	public validPosition : nat * nat * nat ==> bool
		validPosition(x,y,z) == (
			if(x >= 0 and x <= max_lines and y >= min_columns and y <= max_columns and z >= min_floors and z <= max_floors) then
			(
				return true;
			) else (
				return false;
			)
		);
		
	public getNeighbours : PointOfInterest ==> set of PointOfInterest
		getNeighbours(point) == (
			dcl neighboursSet : set of PointOfInterest := {};
			for all p1 in set points do (
				if(p1.GetX() = (point.GetX() - 1) and p1.GetY() = point.GetY() and p1.GetZ() = point.GetZ()) then
				(
					neighboursSet := neighboursSet union {p1};
				) else if (p1.GetX() = (point.GetX() + 1) and p1.GetY() = point.GetY() and p1.GetZ() = point.GetZ()) then 
				(
					neighboursSet := neighboursSet union {p1};
				) else if (p1.GetX() = point.GetX() and p1.GetY() = (point.GetY() - 1) and p1.GetZ() = point.GetZ()) then 
				(
					neighboursSet := neighboursSet union {p1};
				) else if (p1.GetX() = point.GetX() and p1.GetY() = (point.GetY() + 1) and p1.GetZ() = point.GetZ()) then 
				(
					neighboursSet := neighboursSet union {p1};
				)
			);
			return neighboursSet;
		);
		--pre condition point in points of building?
		--post condition all points of returned set are in points of building
		
		
		--GET SHORTEST PATH P1 TO P2		
		
		--GET SHORTEST ACCESSIBLE PATH 
		
		--GET CLOSER TYPE OF EQUIPMENT
	
end Building