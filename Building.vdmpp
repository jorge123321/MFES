class Building
types
	 public Points = set of PointOfInterest;
	 public Transports = set of Transport;
	 public Equipments = set of Equipment;
	 public Edge = set of PointOfInterest
	 inv e == card(e)=2;
	 
   --public Wgraph :: e : Edge
			--					 w : Weight;

instance variables
	public points : Points := {};
	public transports : Transports := {};
	public equipments : Equipments := {};
	public path : Points := {};
	public origin : PointOfInterest;
	public destination : PointOfInterest;
	public s : PointOfInterest;
	public C: Points := {};
 	public Q: Points := {}; -- := points??
 	public dist: map PointOfInterest to nat := {|->};
 	public pred: map PointOfInterest to PointOfInterest := {|->};
 	public edges : set of Points := {};


	

functions
	-- checks if we're only moving 1 position at a time, ie one move on the x left or right, one move on y up or down and one move on z up or down
	public moveIsValid : nat * nat * nat -> bool
			moveIsValid(deltaX, deltaY, deltaZ) == (
				(deltaX = 0 and deltaY = 0 and deltaZ = 1) or
				(deltaX = 0 and deltaY = 0 and deltaZ = -1) or
				(deltaX = 1 and deltaY = 0 and deltaZ = 0) or
				(deltaX = -1 and deltaY = 0 and deltaZ = 0) or
				(deltaX = 0 and deltaY = 1 and deltaZ = 0) or
				(deltaX = 0 and deltaY = -1 and deltaZ = 0)
			);

operations

	--create a building
	public Building:() ==> Building
	Building() == (		
		for i = 0 to 9 do
		(
			for j = 0 to 9 do
			(
					for k = 0 to 2 do 
					(
						dcl point: PointOfInterest := new PointOfInterest(i,j,k,<Null>);
						addPoint(point);
					)
			)
		);
		
			let vert = power(points) in (
				let tempedges = { e | e in set vert & card(e)=2} in(
					edges := tempedges; 
				)
			)
		);
		
		
	--Dijkstra
	public dijkstra: () ==> Building`Points * map PointOfInterest to int * map PointOfInterest to PointOfInterest
		dijkstra() == (
			Q := points;
			s := origin;
			C := C union {s};
			dist := dist ++ {s|->0};
			pred := dist ++ {s|->s};
			
			while(C inter Q <> {}) do (
				let u in set C inter Q be st (forall u1 in set C inter Q & dist(u)<=dist(u1)) in (
					Q := Q\{u};
				
					for all v in set Q do(
						--if(v in set getNeighbours(u)) then(
							let length=dist(u)+1 in(
								if v in set C then(
									if length < dist(v) then(
										dist := dist ++ {v|->length};
										pred := pred ++ {v|-> u};
									)
								)
								else (
									dist := dist ++ {v|->length};
									pred := pred ++ {v|->u};
									C := C union {v};
								)
							)
						--)
					);				
				)
			);
			return mk_(C,dist,pred);
	);
	
		
	-- Add an origin point to the building for the algorithm 
	public addOrigin: nat * nat * nat ==> bool
		addOrigin(x,y,z) == (
			for all p in set points do (
				if p.GetX() = x and p.GetY() = y and p.GetZ() = z
				then (
					changePoint(p, x, y, z, <Origin>);
					origin := p;
					return true;
				)
			);
			return false;
		);
		--pre --TODO: maybe check that the point CAN be set as origin? like it's a clear path or not a wall
		--post --TODO: maybe check that the point WAS set as origin? like it's description indicates origin
		
	-- Add an origin point to the building for the algorithm 
	public addDestination: nat * nat * nat ==> bool
		addDestination(x,y,z) == (
			for all p in set points do (
				if p.GetX() = x and p.GetY() = y and p.GetZ() = z
				then (
					changePoint(p, x, y, z, <Destination>);
					destination := p;
					return true;
				)
			);
			return false;
		);
		--pre P in set points --TODO: maybe check that the point CAN be set as destination? like it's a clear path or not a wall
		--post P in set points; --TODO: maybe check that the point WAS set as destination? like it's description indicates destination
		
		-- checks if building has only 1 destination point
		public hasDestination : () ==> bool
			hasDestination() == (
				dcl pointsDestination : Points := {};
				for all p in set points do (
					if p.GetDesc() = <Destination>
					then (
						pointsDestination := pointsDestination union {p};
					)
				);
				if card(pointsDestination) = 1 then (
					return true;
				) else ( return false; )
			);
			
		-- checks if building has only 1 origin point
		public hasOrigin : () ==> bool
			hasOrigin() == (
				dcl pointsOrigin : Points := {};
				for all p in set points do (
					if p.GetDesc() = <Origin>
					then (
						pointsOrigin := pointsOrigin union {p};
					)
				);
				if card(pointsOrigin) = 1 then (
					return true;
				) else ( return false; )
			);
		
	-- Add a point to the building
	public addPoint: PointOfInterest ==> ()
		addPoint(P) == (
				points := points union {P};
			return;
		)
		pre P not in set points
		post P in set points;
		
	-- Add a stair to the building
	public addTransport: Transport ==> ()
		addTransport(T) == (
				transports := transports union {T};
			return;
		)
		pre T not in set transports
		post T in set transports;
		
	-- Add an equipment to the building
	public addEquipment: Equipment ==> ()
		addEquipment(E) == (
				equipments := equipments union {E};
			return;
		)
		pre E not in set equipments
		post E in set equipments;
		
	-- Change X Y Z and Description of point of interest 
	public changePoint: PointOfInterest*nat*nat*nat*PointOfInterest`Type ==> ()
		changePoint(P,newx, newy, newz, newdesc) == (
			P.changePoint(newx, newy,newz,newdesc);
			return;
		)
		pre P in set points;
	
	-- Change X Y, Description, DownFloor, UpFloor and Type of stair
	public changeTransport: Transport*Transport`X * Transport`Y * Transport`Desc * Transport`DownFloor * Transport`UpFloor * Transport`Type ==> ()
		changeTransport(T,newx, newy, newdesc, newdown, newup, newtype) == (
			T.changeTransport(newx, newy, newdesc, newdown, newup, newtype);
			return;
		)
		pre T in set transports;
		
	-- Change X Y, Z and name of equipment
	public changeEquipment: Equipment * Equipment`X * Equipment`Y * Equipment`Z * Equipment`Name ==> ()
		changeEquipment(E, newx, newy, newz, newname) == (
			E.changeEquipment(newx, newy, newz, newname);
			return;
		)
		pre E in set equipments;
	
	-- Remove point of interest
	public removePoint: PointOfInterest ==>()
		removePoint(P) == (
			points := points \ {P};
			return;
		)
		pre P in set points
		post P not in set points;
	
	-- Remove transport
	public removeTransport: Transport ==>()
		removeTransport(T) == (
			transports := transports \ {T};
			return;
		)
		pre T in set transports
		post T not in set transports;
		
	-- Remove equipment
	public removeEquipment: Equipment ==>()
		removeEquipment(E) == (
			equipments := equipments \ {E};
			return;
		)
		pre E in set equipments
		post E not in set equipments;
		
		--Remove all points
		public removePoints:() ==> ()
			removePoints() == (
				points := points \ points;
			) 
		pre points <> {}
		post points = {};
		
		--Remove all transports
		public removeTransports:() ==> ()
			removeTransports() == (
				transports := transports \ transports;
			) 
		pre transports <> {}
		post transports = {};
		
		--Remove all equipments
		public removeEquipments:() ==> ()
			removeEquipments() == (
				equipments := equipments \ equipments;
			) 
		pre equipments <> {}
		post equipments = {};
		
		--GET SHORTEST PATH P1 TO P2		
		
		--GET SHORTEST ACCESSIBLE PATH 
		
		--GET CLOSER TYPE OF EQUIPMENT
	
end Building